---
layout: post
title: 柔性数组（Flexible array member）
subtitle:   结构体末尾的一些技巧
date: 2016-09-10 09:09:37 +08:00
author:     "VernonSong"
header-img: "img/post-bg-flex.png"
catalog: true
tags:
    - C++
---
### 柔性数组简介
在看一些代码的时候，发现有的结构体最后有一个大小为1或0的数组，就非常不解，这是什么意思，跟声明一个指针有什么区别呢。上网查了一些资料，发现这还是包含了一些门道的，它有一个专门的名字，叫做柔性数组（或者叫柔性数组成员？这种小事无所谓了）。

```cpp
struct test
{
	int num;
	int buffer[0];
};
```
首先要明白的是，如果buffer不是结构体的最后一个元素，编译器会报错，因为这样buffer不是一个完整的数据类型，如果是buffer[]更是如此。但当它出现在结构体的最后时，就变成了C99标准中的柔性数组（上面的代码在VS2013里会有警告，提示并非标准拓展，所以有时使用大小为1的数组，虽然还是用了柔性数组的思想，但是方便跨平台），至于柔性数组的作用，我结合别人的文章以及自己的心得做一些不成熟的分析。
### 柔性数组优缺点

```cpp
struct test
{
	int num;
	int buffer[1];
	int c;
};
int main()
{
	test *a = (test*)malloc(sizeof(struct test)+2*sizeof(int));
	a->buffer[0] = 1;
	a->buffer[1] = 2;
	a->buffer[2] = 3;
	cout<<sizeof(a);
}
```
对于上面的程序，输出a的大小结果为4，即使我们分配给了他额外的2个int大小的内存。我在测试时上面的赋值语句并没有报错，buffer[0]，buffer[1]，buffer[2]都是跟在结构体a后面，而我们知道我们其实只额外给了它2个int的空间，所以我认为这是使用柔性数组的一个缺点。但存在即是又道理的，柔性数组有着很强的优点以至于我们在有些时候会去用它。

- 与普通数组相比，可以根据后来需要来分配大小，不用刚开始声明一个很大的数组，节省了空间
- 与指针相比，在创建结构的时候就把结构体的空间连同那一块需要动态规划的空间一并申请了，结构体与后面的柔性数组在内存上相连，减少了内存碎片化。并且，如果用指针，先分派结构体空间，再分配指针所指向的空间，如果在分配指针所指向的空间时失败了，这个结构体就是一个在用途上残缺的结构体，我们没必要再要它，所以还要释放掉它。就算我们正常的使用了，再最后需要释放掉结构体时，要先释放指针所指向的空间，再释放结构体，非常麻烦。

然而这只是C++中众多技巧之一，成长的路还很长。