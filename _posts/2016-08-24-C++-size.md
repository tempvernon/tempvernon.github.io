---
layout: post
title:   关于结构体与类的大小
subtitle:   "一些内存与类的机制"
date: 2016-08-24 10:09:30 +08:00
author:     "VernonSong"
header-img: "img/post-bg-size.jpg"
catalog: true
tags:
    - C++
---
时常遇到考察结构体或类所占内存大小的题目，在看一些源代码时，也接触到了一些相关的东西，于是在这里把这方面知识总结总结。

### 内存对齐
还是直接看例子（都是32位平台）

```cpp
struct Test
{
    int a ;
    double b ;
    char c ;
    short d;
};    
```

int是4字节，double是8字节，char是1字节，short是2字节，加起来是15，但是，这个结构体实际会占用24字节，24字节！不是16，不是32，是24！
之所以占用了24字节，是因为有内存对齐这个机制存在，所谓内存对齐，就是数据不能想当然的挨着前面所存储数据，而是要根据一定的规矩保持距离。**默认的对齐方式是先按数据类型自身进行对齐，然后再按整个结构体（类）进行对齐**。
<br>
<br>于是对于上面的结构体，把他们假设为一个入座的过程，在4字节的a坐下后，接下来的b表示自己是8字节的，要按照8字节的规矩入座，所以它与前面a保持了4字节的距离。这样，a和b加起来占了16。后面的c的大小是1字节，所以它不挑，挨着b座下来，现在一共占了17字节。最后的d是2字节的，它也一定要前面时2字节的倍数才肯坐，所以它与c中间隔了一个1字节。这么算下去，一共占了20字节。但还没有结束，因为整个结构体还没有对齐，因为结构体中最占位子的数据类型是double，占了8字节，所以整个结构体要按8字节对齐，因此结构体大小为24字节。
<br>
<br>如此折腾的进行一番对齐，并不是简简单单为了好看，而是对于一些CPU来说，读取未对齐的数据会令它们很苦恼，有的会直接傲娇的报错，有的即使成功读了，也因为数据存放在奇数位上而进行两次读取，降低了访问速度。所以，这也算是时间与空间之间的博弈。
<br>
<br>还有一个差点忘写的是一个空的类或结构体，它的大小是1字节，这是因为C++规定任何不同的对象不能拥有相同的地址。

### 修改对齐方式
如果想修改默认的对齐方式，可以使用#pragma pack()这个预处理命令，比如对于上面的结构体，如果在前面加上#pragma pack(4)使其对齐方式变为4字节对齐，b就不能挑剔的在a后面4个字节后再就坐了，挨着a就已满足了要求的对齐方式。最后整个结构体也无需按照b的大小进行对齐。所以最后其大小为16。
<br>
<br>我看源代码中使用的是#pragma pack(push,_CRT_PACKING)，表示从现在开始按照_CRT_PACKING所表示的字节数对齐，像是把这个对齐方式压入特定的栈中一样，实际也确实有#pragma pack（pop)这个命令来还原对齐方式。

### （虚）函数对类实例大小的影响

```cpp
class Test
{
	char a;
	void b(){}
	virtual void c(){}
	virtual void d(){}
};
```
这个类的实例大小是8字节，通过内存对齐的只是已经能猜出a后面有3字节的空位，那么剩下的4字节是谁占的呢？
<br>
<br>答案是虚函数，由于虚函数特殊的性质，所以需要在它运行时确定该对象应该调用哪一个虚函数，为了实现这样目标，C++为每个类及其派生类建立一张虚函数表，同时给每个实例建立一个指针来指向合适的函数。所以这4字节便是被一个指针所占用的。在这种简单的情况下，每个对象只有一个虚函数的指针。
<br>
<br>不管虚函数写在哪，他在内存中的位置都是在此类的数据成员前的。但是我有一点不明白，比如当数据成员有int和double，且int在前，虚函数的指针在最前面，int本应该跟在虚函数的指针后面，但却隔了4个位置，猜测是放在数据成员前会先来一次整体对齐。
<br>
<br>而对于普通的成员函数，由于是所有实例共享的，调用时便通过隐藏的this指针和类的实例相关联，函数代码编译后根本就不在类实例中，所以不占实例空间。

### （虚）继承对类实例大小的影响
```cpp
class CommonBase  
{  
    int co;  
};  
  
class Base1: virtual public CommonBase  
{  
public:  
    virtual void print1() {  }  
    virtual void print2() {  }  
private:  
    int b1;  
};  
  
class Base2: virtual public CommonBase  
{  
public:  
    virtual void dump1() {  }  
    virtual void dump2() {  }  
private:  
    int b2;  
};  
  
class Derived: public Base1, public Base2  
{  
public:  
    void print2() {  }  
    void dump2() {  }  
private:  
    int d;  
};  
```
懒得写了，从别人哪里复制来的测试代码，对于普通继承，就是在先放把父类按照正常程序放进去，再放自己，所以这里先放入Base1，再放入Base2，而对于虚继承，原理于虚函数类似，需要一个指针指向虚基表，并且还要在最后放入基类的。那么，Base1的大小即为4字节虚函数指针，4字节虚基表指针，4字节数据成员int，4字节基类成员int。为16字节。Derived虽然看上去很复杂，但是也很容易推算出它的大小为12字节Base1（先不放被虚继承的基类成员），12字节的Base2，4字节的自身数据成员d，最后被虚继承的4字节基类成员co，加起来32字节。
<br>
<br>对于为什么已经有指向虚基表的指针还需要最后放入被虚继承的基类，我也不甚理解，打算以后掌握了这方面知识再来补充。

### 类中的static关键字
当用static关键字修饰类中的变量时，可以使其成为静态数据成员。与静态全局变量还有静态局部变量一样，静态数据成员也是在全局数据区分配内存，并且无论有多少个实例，都只给静态数据成员分配一次内存，每个对象都使用和更新那一个数据。因此，它也不影响类实例的大小。
<br>
<br>比较有意思的是就算没有类的实例，静态数据成员的作用域也是可见的，却没有进入全局命名空间（访问静态数据成员：类名::静态数据成员名）。但它遵循public，private这样的访问规则。
<br>
<br>而如果用static修饰成员函数，则可以使其成为静态成员函数。之前说到过普通成员函数通过隐含的this指针指向类的实例本身来工作，因此不占用类的实例大小。而静态成员函数虽然也不占用实例大小，但是它不予任何实例相联系，所以不需要this指针。虽然速度上会有些许增长，但这样它就无法访问类的非静态数据成员，也无法访问非静态成员函数。这是使用时需要注意的。