---
layout: post
title: C++函数参数入栈与函数调用约定
subtitle:  从项目再看C++
date: 2016-12-20 09:09:37 +08:00
author:     "VernonSong"
header-img: "img/post-bg-push_parameter.jpg"
catalog: true
tags:
    - C++
---
## 前言
在家中看公司的项目源代码，咀嚼起来觉得很费劲，一方面是因为自身水平原因，一方面也是因为代码没有文档，只有一些注释，但项目内容又离平常所见的东西比较遥远。不过好在时间充裕，能让自己边看边问边学，向技术小牛犊子迈进。

## 正文

### C++函数参数入栈顺序
说到函数的参数入栈的顺序，以前想当然的以为是从左往右，而今天研究一个以前没见过的关键字的时候，才发现原来C++默认的函数参数入栈的顺序是从右往左的，看上去很迷？来亲自试一试！

```cpp
#include<iostream>
using namespace std;
void test(int a, int b, int c)
{
	cout << "参数在栈中地址" << endl;
	cout << "a:" << &a << endl;
	cout << "b:" << &b << endl;
	cout << "c:" << &c << endl;
}
int main()
{
	int a = 1, b = 2, c = 3;
	cout << "变量在栈中地址" << endl;
	cout << "a:" << &a << endl;
	cout << "b:" << &b << endl;
	cout << "c:" << &c << endl;
	test(a, b, c);
	return 0;
}
```
 运行结果为：
<br>变量在栈中地址
<br>a:00E8FAC0
<br>b:00E8FAB4
<br>c:00E8FAA8
<br>参数在栈中地址
<br>a:00E8F9CC
<br>b:00E8F9D0
<br>c:00E8F9D4
<br>
<br>因为在栈区，栈底为高地址，栈顶为低地址。所以可以很清楚的看到刚开始作为变量，a，b，c是以声明的顺序压入栈中（a的地址最高，在栈底，c的地址最低，在栈顶），而在函数中，参数a，b，c是倒着被压入栈中的（a的地址最低，在栈顶，c的地址最高，在栈底）。所以虽然看上去比较违反常理，但确实在C++中参数是从右往左进入栈中的。

可是为什么要这么设计呢？上网查找了一些资料，得出的结论是：此约定继承自C，目的是为了能使用可变形参函数。
<br>
<br>对于可变形参函数，这个博主的[【C++笔记】可变参数函数](http://blog.csdn.net/qq_35280514/article/details/51637920)写的比较清晰。
<br>
<br>不讨论用C++的方法实现可变形参函数与函数参数入栈顺序有没有关联，就C语言的可变形参函数而言，从右向左入栈，保证生成汇编语言时这些参数相对于BP指向的栈位置的偏移量是固定的。如果从左向右入栈，则从BP指向的位置到参数的偏移量就会根据用户传入的参数数量而发生改变，这时编译器的识别难度就会大大增加。

### 函数调用约定
<br>最开始研究这个问题的原因，就是因为遇到了__stdcall这些以前没见过的关键字，在这里统一整理一下

#### __cdecl
C/C++默认的函数调用方式，其主要特征是：
1. 参数是从右向左传递的，也是放在堆栈中。
2. 堆栈平衡是由调用函数来执行的。

因为C语言的可变参数函数，被调用函数内就无法知道参数究竟使用了多少个字节，我们必须要在被调函数执行之后我们才知道参数究竟用了多少字节，所以我们让调用者来进行堆栈平衡操作。因此，有些函数只能调用该约定（如printf）。

#### __stdcall
Win32 API函数绝大部分都是采用*_*_stdcall调用约定的。WINAPI其实也只是__stacall的一个别名而已。在项目中，也可以看到

```cpp
#define WINAPI __stdcall
```
__stdcall调用约定的主要特征是：
1. 参数是从右往左传递的，也是放在堆栈中。
2. 函数的堆栈平衡操作是由被调用函数执行的。

因为栈的清理（堆栈平衡操作）是由被调用函数执行的。所以使用*_*_stdcall调用约定生成的可执行文件要比__cdecl的要小，因为在每次的函数调用都要产生堆栈清理的代码。
几乎所有的语言都支持__stdcall调用，因此，在写用于共享的代码时，使用*_*_stdcall调用比较好。

#### __fastcall
顾名思义，就是快速调用，其主要特征是：
1. 最左边的两个不大于4个字节（DWORD）的参数分别放在ecx和edx寄存器，剩下的参数仍旧自右向左压入栈中。
2. 函数的堆栈平衡操作是由被调用函数执行的。

#### 其他
__pascal：Pascal语言的函数调用方式，也可以在C/C++中使用，参数压栈顺序与前两者相反。返回时的清栈方式与_stdcall相同。
<br>
<br>__thiscall：仅仅应用于"C++"成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。
<br>
<br>__nakedcall：采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用。